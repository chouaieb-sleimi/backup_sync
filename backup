#!/usr/bin/env bash
#set -xv

###################
## Variables

BACKUP_CONF="$HOME/.backup_config"
TIMESTAMP_START=$(date +%Y-%m-%d_%H-%M-%S)
LOG_SUCCESS="success_backup.log"
LOG_ERROR="error_backup.log"
LOG_FILE=""

# defined in $BACKUP_CONF/backup_${PROFILE}_vars
#  # backup source paths
#  SRC_FOLDER=
#  ENV_FILES=()
#
#  # backup destintaion and device paths
#  DEFAULT_DEVICE_NAME=
#  DEVICE_NAME=
#  DEVICE_PATH=
#  DEST_FOLDER=
#
#  VSCODE_PROFILE="base"

###################
## Functions

display_usage() {
    echo "Usage: backup [-h] [-p PROFILE]"
}

display_help() {
    display_usage
    echo
    echo "This script backs up files based on different backup profiles. Each backup profile has one backup source and destination folders and multiple environment files outside the source and destination folders."
    echo
    echo "Each backup profile uses 2 variable files under the folder defined in \$BACKUP_CONF variable; \"backup_[PROFILE]_vars\" and \"backup_[PROFILE]_exclusion\"."
    echo "\"backup_[PROFILE]_vars\" is a shell script that defines variables specific to each backup profile. \"backup_[PROFILE]_exclusion\" file defines files and/or folders that are excluded from the backup source."
    echo
    echo "backup_[PROFILE]_vars example:"
    echo "    SRC_FOLDER=\$HOME"
    echo "    ENV_FILES=(/etc/hosts)"
    echo "    DEVICE_PATH=/run/media/dave/backupUSB"
    echo "    DEST_FOLDER=\$DEVICE_PATH/homeBackup"
    echo
}

exit_error() {
    display_usage
    exit 1
}

# log() - writes messages to both stderr and log file with timestamp
log() {
    local message=$1
    local timestamp=$(date +%Y-%m-%d_%H:%M:%S)
    echo "$message" >&2
    if [[ -n "$LOG_FILE" ]]; then
        echo "$timestamp | $message" >> "$LOG_FILE"
    fi
}

log_info() {
    log "[INFO] $1"
}

log_error() {
    log "[ERROR] $1"
}

log_section() {
    log "======== $1 ========"
}

# Main function
#
# This function takes care of parsing command line arguments and performs the appropriate action.
# If no arguments are provided, it displays the help message and exits.
# If any argument other than the allowed POSIX arguments is provided, it exits with an error code.
#
# If the '-p' argument is provided, it sets the profile name and reads the corresponding variable files.
# It then checks if the source and destination folders exist and if not, it exits with an error code.
# Finally, it performs the backup and displays the results.
main() {
    # when called with no argument
    [[ $@ == "" ]] && display_help && exit 0

    # only allow POSIX arguments
    [[ $(echo "$@" | grep -vE "^(-.( [a-z]+)?)$") ]] && exit_error

    while getopts :p:h option; do
        case $option in
        p)
            PROFILE=$OPTARG
            read_profile_vars
            read -p "Device name [$DEFAULT_DEVICE_NAME]: " device_name
            DEVICE_NAME=${DEVICE_NAME:-"$DEFAULT_DEVICE_NAME"}
            DEVICE_PATH="/run/media/$USER/$DEVICE_NAME"
            DEST_FOLDER="$DEVICE_PATH/$DEV_DEST_FOLDER"
            LOG_FILE="$DEVICE_PATH/backup_$TIMESTAMP_START.log"

            [[ ! -d $SRC_FOLDER ]] && echo "ERROR | Source folder $SRC_FOLDER not found" && exit_error
            [[ ! -d $DEVICE_PATH ]] && echo "ERROR | Backup device \"$DEVICE_NAME\" not found at $DEVICE_PATH" && exit_error
            [[ ! -d "$DEST_FOLDER" ]] && mkdir -p "$DEST_FOLDER" && echo "[INFO] Created destination folder: $DEST_FOLDER"

            backup
            analyse_backup_results
            exit 0
            ;;
        h)
            display_help
            ;;
        :)
            [[ $OPTARG == "p" ]] && echo "ERROR | PROFILE required"
            exit_error
            ;;
        ?)
            echo "ERROR | unkown option -$OPTARG"
            exit_error
            ;;
        *)
            echo "ERROR | invalid operation $*"
            exit_error
            ;;
        esac
    done
}

# Read variables from config files.
#
# This function reads 2 config files under "$BACKUP_CONF" folder:
# - "backup_${PROFILE}_exclusion" that defines files and/or folders that are excluded from the backup source.
# - "backup_${PROFILE}_vars" that defines variables specific to each backup profile.
#
# If any of the config files doesn't exist, this function will exit with an error code.
read_profile_vars() {
    # read EXCLUSION_FILE
    EXCLUSION_FILE="$BACKUP_CONF/backup_${PROFILE}_exclusion"
    if [[ -f $EXCLUSION_FILE ]]; then
        echo "[INFO] Reading exclusion list from: $EXCLUSION_FILE"
    else
        echo "[ERROR] Exclusion file not found: $EXCLUSION_FILE"
        exit_error
    fi

    # read VARS_FILE
    VARS_FILE="$BACKUP_CONF/backup_${PROFILE}_vars"
    if [[ -f $VARS_FILE ]]; then
        echo "[INFO] Reading backup vars from: $VARS_FILE"
        source $VARS_FILE
    else
        echo "[ERROR] Variables file not found: $VARS_FILE"
        exit_error
    fi
    echo ""
}

# backup() - backs up files based on the backup profile defined in $BACKUP_CONF/backup_${PROFILE}_vars and $BACKUP_CONF/backup_${PROFILE}_exclusion
#
# This function does the following operations:
# - clean previous timestamp
# - write new timestamp
# - backup environment files
# - backup src_folder
backup() {
    log_section "STARTING BACKUP"
    log_info "Log file: $LOG_FILE"
    log_info "Backup Profile: $PROFILE"
    log_info "Backup Source: $SRC_FOLDER"
    log_info "Backup Destination: $DEST_FOLDER"
    
    # clean previous timestamp
    [[ $(find $DEVICE_PATH/ -maxdepth 1 -name "timestamp*") ]] && rm $DEVICE_PATH/timestamp*

    # write new timestamp
    cat >$LOG_FILE <<EOF
=======================================
= backup performed at $TIMESTAMP_START
=======================================
EOF

    backup_env_files

    log_info "Starting backup of $SRC_FOLDER to $DEST_FOLDER"
    # backup SRC_FOLDER
    rsync -av --inplace \
        --delete --delete-excluded \
        --exclude-from=$EXCLUSION_FILE \
        $SRC_FOLDER/ $DEST_FOLDER/ \
        > >(tee $DEVICE_PATH/$LOG_SUCCESS) \
        2> >(tee $DEVICE_PATH/$LOG_ERROR)
    log_info "Completed backup of $SRC_FOLDER to $DEST_FOLDER"
    log_section "BACKUP COMPLETE"
}

# backup_env_files() - backs up environment files and folders to $ENV_FILES_DEST
#
# This function backs up:
# - /etc/yum.repos.d/
# - package list to $ENV_FILES_DEST/package_list
# - env_files defined in backup_${PROFILE}_vars file
# - vs code's extension list to $ENV_FILES_DEST/code_extensions
backup_env_files() {
    log_section "BACKING UP ENVIRONMENT FILES"
    
    ENV_FILES_DEST="$DEVICE_PATH/env_files"
    # create $ENV_FILES_DEST dir
    if [[ ! -d $ENV_FILES_DEST ]]; then
        mkdir -p $ENV_FILES_DEST
        log_info "Created directory: $ENV_FILES_DEST"
    fi

    # backup repo list
    rsync -av --inplace \
        --delete \
        --chown=chouaieb:chouaieb \
        /etc/yum.repos.d $ENV_FILES_DEST/
    log_info "Backed up /etc/yum.repos.d to $ENV_FILES_DEST/yum.repos.d"

    # backup package list
    rpm -qa >$ENV_FILES_DEST/package_list
    log_info "Backed up package list to $ENV_FILES_DEST/package_list"

    # backup env files
    if [[ ${#ENV_FILES[@]} -eq 0 ]]; then
        log_info "No environment files to backup"
    else
        log_info "Backing up environment files..."
        # Create metadata file to preserve original paths
        > "$ENV_FILES_DEST/env_files.manifest"
        for file in ${ENV_FILES[@]}; do
            rsync -av --inplace \
                --delete \
                $file $ENV_FILES_DEST/
            log_info "    Backed up: $file"
            
            # Record original path in manifest for restore
            if [[ -e $file ]]; then
                # Use base name as key, original path as value
                base=$(basename "$file")
                echo "$base|$file" >> "$ENV_FILES_DEST/env_files.manifest"
            fi
        done
    fi

    # vscode backup
    rsync -av --inplace --delete "$HOME/.config/Code/User" "$ENV_FILES_DEST/vscode/"
    log_info "Backed up VS Code user settings to $ENV_FILES_DEST/vscode/User"

    code --list-extensions --profile $VSCODE_PROFILE >$ENV_FILES_DEST/vscode/code_extension_list
    log_info "Backed up VS Code extensions list to $ENV_FILES_DEST/vscode/code_extension_list"

    # backup the backup configuration itself to make backups portable
    if [[ -d "$BACKUP_CONF" ]]; then
        log_info "Packaging backup configuration from $BACKUP_CONF to $DEVICE_PATH/backup_config/"
        rsync -av --delete "$BACKUP_CONF/" "$DEVICE_PATH/backup_config/"
        log_info "Packaged backup configuration to $DEVICE_PATH/backup_config/"
    else
        log_info "No backup config directory found at $BACKUP_CONF, skipping packaging"
    fi


    
    log_section "ENVIRONMENT FILES BACKUP COMPLETE"
}

analyse_backup_results() {
    if [[ -f $DEVICE_PATH/$LOG_ERROR && -f $DEVICE_PATH/$LOG_SUCCESS ]]; then
        success_count=$(wc -l $DEVICE_PATH/$LOG_SUCCESS | cut -d" " -f1)
        success_count=$(($success_count - 4))
        errors_count=$(wc -l $DEVICE_PATH/$LOG_ERROR | cut -d" " -f1)

        echo
        echo "- $success_count successful operations"
        echo "- $errors_count errors occured"

        if [[ $errors_count -gt 0 ]]; then
            read -p "Review errors? [Y/n] " read_errors
            read_errors=${read_errors:-y}

            [[ $read_errors == "y" ]] && less $DEVICE_PATH/$LOG_ERROR
        fi
    fi
}

###################
## Script start

[[ "${BASH_SOURCE[0]}" == "$0" ]] && main $@
